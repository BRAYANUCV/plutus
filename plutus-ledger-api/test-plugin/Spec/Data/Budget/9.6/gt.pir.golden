let
  data Bool | Bool_match where
    True : Bool
    False : Bool
  !f : integer -> integer -> Bool
    = \(x : integer) (y : integer) ->
        ifThenElse {Bool} (lessThanInteger x y) False True
  !`$dToData` : (\a -> a -> data) Bool
    = \(ds : Bool) ->
        Bool_match
          ds
          {all dead. data}
          (/\dead -> Constr 1 [])
          (/\dead -> Constr 0 [])
          {all dead. dead}
  data Unit | Unit_match where
    Unit : Unit
  !`$fAdditiveGroupValue` : Unit -> list (pair data data) = \(ds : Unit) -> []
in
letrec
  !pt : list (pair data data) -> list (pair data data)
    = \(lTs : list (pair data data)) ->
        let
          ~hd' : pair data data = headList {pair data data} lTs
        in
        chooseList
          {pair data data}
          {Unit -> list (pair data data)}
          lTs
          `$fAdditiveGroupValue`
          (\(ds : Unit) ->
             mkCons
               {pair data data}
               (mkPairData
                  (fstPair {data} {data} hd')
                  (`$dToData` (f 0 (unIData (sndPair {data} {data} hd')))))
               (pt (tailList {pair data data} lTs)))
          Unit
in
letrec
  !pt : list (pair data data) -> list (pair data data)
    = \(lTs : list (pair data data)) ->
        let
          ~hd' : pair data data = headList {pair data data} lTs
        in
        chooseList
          {pair data data}
          {Unit -> list (pair data data)}
          lTs
          `$fAdditiveGroupValue`
          (\(ds : Unit) ->
             mkCons
               {pair data data}
               (mkPairData
                  (fstPair {data} {data} hd')
                  (`$dToData` (f (unIData (sndPair {data} {data} hd')) 0)))
               (pt (tailList {pair data data} lTs)))
          Unit
in
let
  !insert' : data -> data -> list (pair data data) -> list (pair data data)
    = \(k : data) (a : data) ->
        letrec
          !go : list (pair data data) -> list (pair data data)
            = \(xs : list (pair data data)) ->
                chooseList
                  {pair data data}
                  {Unit -> list (pair data data)}
                  xs
                  (\(ds : Unit) -> mkCons {pair data data} (mkPairData k a) [])
                  (\(ds : Unit) ->
                     let
                       !hd : pair data data = headList {pair data data} xs
                       !tl : list (pair data data)
                         = tailList {pair data data} xs
                     in
                     ifThenElse
                       {all dead. list (pair data data)}
                       (equalsData k (fstPair {data} {data} hd))
                       (/\dead -> mkCons {pair data data} (mkPairData k a) tl)
                       (/\dead -> mkCons {pair data data} hd (go tl))
                       {all dead. dead})
                  Unit
        in
        \(eta : list (pair data data)) -> go eta
in
letrec
  !`$fAdditiveGroupValue_safeAppendInner` :
     list (pair data data) -> list (pair data data) -> list (pair data data)
    = \(xs : list (pair data data)) ->
        let
          ~hd : pair data data = headList {pair data data} xs
        in
        \(xs : list (pair data data)) ->
          chooseList
            {pair data data}
            {Unit -> list (pair data data)}
            xs
            (\(ds : Unit) -> xs)
            (\(ds : Unit) ->
               insert'
                 (fstPair {data} {data} hd)
                 (sndPair {data} {data} hd)
                 (`$fAdditiveGroupValue_safeAppendInner`
                    (tailList {pair data data} xs)
                    xs))
            Unit
in
let
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
  !lookup' : data -> list (pair data data) -> Maybe data
    = \(k : data) ->
        letrec
          !go : list (pair data data) -> Maybe data
            = \(xs : list (pair data data)) ->
                chooseList
                  {pair data data}
                  {Unit -> Maybe data}
                  xs
                  (\(ds : Unit) -> Nothing {data})
                  (\(ds : Unit) ->
                     let
                       !hd : pair data data = headList {pair data data} xs
                     in
                     ifThenElse
                       {all dead. Maybe data}
                       (equalsData k (fstPair {data} {data} hd))
                       (/\dead ->
                          let
                            !ds : list (pair data data)
                              = tailList {pair data data} xs
                          in
                          Just {data} (sndPair {data} {data} hd))
                       (/\dead -> go (tailList {pair data data} xs))
                       {all dead. dead})
                  Unit
        in
        \(m : list (pair data data)) -> go m
in
letrec
  !`$fAdditiveGroupValue_safeAppend` :
     list (pair data data) -> list (pair data data) -> list (pair data data)
    = \(xs : list (pair data data)) ->
        let
          ~hd : pair data data = headList {pair data data} xs
          ~k : data = fstPair {data} {data} hd
        in
        \(xs : list (pair data data)) ->
          chooseList
            {pair data data}
            {Unit -> list (pair data data)}
            xs
            (\(ds : Unit) -> xs)
            (\(ds : Unit) ->
               Maybe_match
                 {data}
                 (lookup' k xs)
                 {all dead. list (pair data data)}
                 (\(v' : data) ->
                    /\dead ->
                      insert'
                        k
                        (mapData
                           (`$fAdditiveGroupValue_safeAppendInner`
                              (unMapData (sndPair {data} {data} hd))
                              (unMapData v')))
                        (`$fAdditiveGroupValue_safeAppend`
                           (tailList {pair data data} xs)
                           xs))
                 (/\dead ->
                    insert'
                      k
                      (sndPair {data} {data} hd)
                      (`$fAdditiveGroupValue_safeAppend`
                         (tailList {pair data data} xs)
                         xs))
                 {all dead. dead})
            Unit
in
letrec
  !rev : all a. list a -> list a -> list a
    = /\a ->
        \(l : list a) (acc : list a) ->
          chooseList
            {a}
            {Unit -> list a}
            l
            (\(ds : Unit) -> acc)
            (\(ds : Unit) ->
               rev {a} (tailList {a} l) (mkCons {a} (headList {a} l) acc))
            Unit
in
let
  !`$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData` : data -> data
    = \(d : data) -> d
  !all :
     all k a.
       (\a -> data -> a) a ->
       (a -> Bool) ->
       (\k a -> list (pair data data)) k a ->
       Bool
    = /\k a ->
        \(`$dUnsafeFromData` : (\a -> data -> a) a) (p : a -> Bool) ->
          letrec
            !go : list (pair data data) -> Bool
              = \(xs : list (pair data data)) ->
                  chooseList
                    {pair data data}
                    {Unit -> Bool}
                    xs
                    (\(ds : Unit) -> True)
                    (\(ds : Unit) ->
                       Bool_match
                         (p
                            (`$dUnsafeFromData`
                               (sndPair
                                  {data}
                                  {data}
                                  (headList {pair data data} xs))))
                         {all dead. Bool}
                         (/\dead -> go (tailList {pair data data} xs))
                         (/\dead ->
                            let
                              !ds : list (pair data data)
                                = tailList {pair data data} xs
                            in
                            False)
                         {all dead. dead})
                    Unit
          in
          \(ds : (\k a -> list (pair data data)) k a) -> go ds
  !unordEqWith :
     (data -> Bool) ->
     (data -> data -> Bool) ->
     list (pair data data) ->
     list (pair data data) ->
     Bool
    = \(is : data -> Bool)
       (eqV : data -> data -> Bool) ->
        letrec
          !goBoth :
             list (pair data data) -> list (pair data data) -> Bool
            = \(l : list (pair data data)) ->
                let
                  ~hd : pair data data = headList {pair data data} l
                  ~v : data = sndPair {data} {data} hd
                  ~tl : list (pair data data) = tailList {pair data data} l
                in
                \(l : list (pair data data)) ->
                  let
                    ~hd : pair data data = headList {pair data data} l
                  in
                  chooseList
                    {pair data data}
                    {Unit -> Bool}
                    l
                    (\(ds : Unit) ->
                       chooseList
                         {pair data data}
                         {Unit -> Bool}
                         l
                         (\(ds : Unit) -> True)
                         (\(ds : Unit) ->
                            all
                              {data}
                              {data}
                              `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                              is
                              l)
                         Unit)
                    (\(ds : Unit) ->
                       chooseList
                         {pair data data}
                         {Unit -> Bool}
                         l
                         (\(ds : Unit) ->
                            all
                              {data}
                              {data}
                              `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                              is
                              l)
                         (\(ds : Unit) ->
                            let
                              !d : data = fstPair {data} {data} hd
                            in
                            letrec
                              !goRight :
                                 list (pair data data) ->
                                 list (pair data data) ->
                                 Bool
                                = \(acc : list (pair data data))
                                   (l : list (pair data data)) ->
                                    let
                                      ~hd : pair data data
                                        = headList {pair data data} l
                                      ~v : data = sndPair {data} {data} hd
                                    in
                                    chooseList
                                      {pair data data}
                                      {Unit -> Bool}
                                      l
                                      (\(ds : Unit) -> False)
                                      (\(ds : Unit) ->
                                         Bool_match
                                           (is v)
                                           {all dead. Bool}
                                           (/\dead ->
                                              goRight
                                                acc
                                                (tailList {pair data data} l))
                                           (/\dead ->
                                              ifThenElse
                                                {all dead. Bool}
                                                (equalsData
                                                   (fstPair {data} {data} hd)
                                                   d)
                                                (/\dead ->
                                                   Bool_match
                                                     (eqV v v)
                                                     {all dead. Bool}
                                                     (/\dead ->
                                                        goBoth
                                                          tl
                                                          (rev
                                                             {pair data data}
                                                             acc
                                                             (tailList
                                                                {pair data data}
                                                                l)))
                                                     (/\dead -> False)
                                                     {all dead. dead})
                                                (/\dead ->
                                                   goRight
                                                     (mkCons
                                                        {pair data data}
                                                        hd
                                                        acc)
                                                     (tailList
                                                        {pair data data}
                                                        l))
                                                {all dead. dead})
                                           {all dead. dead})
                                      Unit
                            in
                            ifThenElse
                              {all dead. Bool}
                              (equalsData d (fstPair {data} {data} hd))
                              (/\dead ->
                                 Bool_match
                                   (eqV v (sndPair {data} {data} hd))
                                   {all dead. Bool}
                                   (/\dead ->
                                      goBoth tl (tailList {pair data data} l))
                                   (/\dead -> False)
                                   {all dead. dead})
                              (/\dead ->
                                 Bool_match
                                   (is v)
                                   {all dead. Bool}
                                   (/\dead -> goBoth tl l)
                                   (/\dead ->
                                      goRight
                                        (Bool_match
                                           (is (sndPair {data} {data} hd))
                                           {all dead. list (pair data data)}
                                           (/\dead -> [])
                                           (/\dead ->
                                              mkCons {pair data data} hd [])
                                           {all dead. dead})
                                        (tailList {pair data data} l))
                                   {all dead. dead})
                              {all dead. dead})
                         Unit)
                    Unit
        in
        \(eta : list (pair data data)) (eta : list (pair data data)) ->
          goBoth eta eta
in
\(l :
    (\k a -> list (pair data data))
      bytestring
      ((\k a -> list (pair data data)) bytestring integer)) ->
  letrec
    !goRight : list (pair data data) -> list (pair data data)
      = \(rightMap : list (pair data data)) ->
          let
            ~hd : pair data data = headList {pair data data} rightMap
            ~curSymb : data = fstPair {data} {data} hd
          in
          chooseList
            {pair data data}
            {Unit -> list (pair data data)}
            rightMap
            `$fAdditiveGroupValue`
            (\(ds : Unit) ->
               Maybe_match
                 {data}
                 (lookup' curSymb l)
                 {all dead. list (pair data data)}
                 (\(leftTokens : data) ->
                    letrec
                      !pt : list (pair data data) -> list (pair data data)
                        = \(lTs : list (pair data data)) ->
                            let
                              ~hd' : pair data data
                                = headList {pair data data} lTs
                              ~tok : data = fstPair {data} {data} hd'
                            in
                            chooseList
                              {pair data data}
                              {Unit -> list (pair data data)}
                              lTs
                              `$fAdditiveGroupValue`
                              (\(ds : Unit) ->
                                 Maybe_match
                                   {data}
                                   (lookup' tok (unMapData leftTokens))
                                   {all dead. list (pair data data)}
                                   (\(leftAmt : data) ->
                                      /\dead ->
                                        mkCons
                                          {pair data data}
                                          (mkPairData
                                             tok
                                             (`$dToData`
                                                (f
                                                   (unIData leftAmt)
                                                   (unIData
                                                      (sndPair
                                                         {data}
                                                         {data}
                                                         hd')))))
                                          (pt (tailList {pair data data} lTs)))
                                   (/\dead ->
                                      mkCons
                                        {pair data data}
                                        (mkPairData
                                           tok
                                           (`$dToData`
                                              (f
                                                 0
                                                 (unIData
                                                    (sndPair
                                                       {data}
                                                       {data}
                                                       hd')))))
                                        (pt (tailList {pair data data} lTs)))
                                   {all dead. dead})
                              Unit
                    in
                    /\dead ->
                      mkCons
                        {pair data data}
                        (mkPairData
                           curSymb
                           (mapData
                              (pt (unMapData (sndPair {data} {data} hd)))))
                        (goRight (tailList {pair data data} rightMap)))
                 (/\dead ->
                    mkCons
                      {pair data data}
                      (mkPairData
                         curSymb
                         (mapData (pt (unMapData (sndPair {data} {data} hd)))))
                      (goRight (tailList {pair data data} rightMap)))
                 {all dead. dead})
            Unit
  in
  \(r :
      (\k a -> list (pair data data))
        bytestring
        ((\k a -> list (pair data data)) bytestring integer)) ->
    letrec
      !goLeft : list (pair data data) -> list (pair data data)
        = \(leftMap : list (pair data data)) ->
            let
              ~hd : pair data data = headList {pair data data} leftMap
              ~curSymb : data = fstPair {data} {data} hd
            in
            chooseList
              {pair data data}
              {Unit -> list (pair data data)}
              leftMap
              `$fAdditiveGroupValue`
              (\(ds : Unit) ->
                 Maybe_match
                   {data}
                   (lookup' curSymb r)
                   {all dead. list (pair data data)}
                   (\(rightTokens : data) ->
                      letrec
                        !pt : list (pair data data) -> list (pair data data)
                          = \(lTs : list (pair data data)) ->
                              let
                                ~hd' : pair data data
                                  = headList {pair data data} lTs
                                ~tok : data = fstPair {data} {data} hd'
                              in
                              chooseList
                                {pair data data}
                                {Unit -> list (pair data data)}
                                lTs
                                `$fAdditiveGroupValue`
                                (\(ds : Unit) ->
                                   Maybe_match
                                     {data}
                                     (lookup' tok (unMapData rightTokens))
                                     {all dead. list (pair data data)}
                                     (\(rightAmt : data) ->
                                        /\dead ->
                                          mkCons
                                            {pair data data}
                                            (mkPairData
                                               tok
                                               (`$dToData`
                                                  (f
                                                     (unIData
                                                        (sndPair
                                                           {data}
                                                           {data}
                                                           hd'))
                                                     (unIData rightAmt))))
                                            (pt
                                               (tailList {pair data data} lTs)))
                                     (/\dead ->
                                        mkCons
                                          {pair data data}
                                          (mkPairData
                                             tok
                                             (`$dToData`
                                                (f
                                                   (unIData
                                                      (sndPair
                                                         {data}
                                                         {data}
                                                         hd'))
                                                   0)))
                                          (pt (tailList {pair data data} lTs)))
                                     {all dead. dead})
                                Unit
                      in
                      /\dead ->
                        mkCons
                          {pair data data}
                          (mkPairData
                             curSymb
                             (mapData
                                (pt (unMapData (sndPair {data} {data} hd)))))
                          (goLeft (tailList {pair data data} leftMap)))
                   (/\dead ->
                      mkCons
                        {pair data data}
                        (mkPairData
                           curSymb
                           (mapData
                              (pt (unMapData (sndPair {data} {data} hd)))))
                        (goLeft (tailList {pair data data} leftMap)))
                   {all dead. dead})
              Unit
    in
    Bool_match
      (all
         {bytestring}
         {(\k a -> list (pair data data)) bytestring Bool}
         (\(eta : data) -> unMapData eta)
         (all
            {bytestring}
            {Bool}
            (\(d : data) ->
               let
                 !tup : pair integer (list data) = unConstrData d
                 !index : integer = fstPair {integer} {list data} tup
                 !args : list data = sndPair {integer} {list data} tup
               in
               ifThenElse
                 {all dead. Bool}
                 (equalsInteger 0 index)
                 (/\dead -> False)
                 (/\dead ->
                    ifThenElse
                      {all dead. Bool}
                      (equalsInteger 1 index)
                      (/\dead -> True)
                      (/\dead -> error {Bool})
                      {all dead. dead})
                 {all dead. dead})
            (\(x : Bool) -> x))
         (`$fAdditiveGroupValue_safeAppend` (goLeft l) (goRight r)))
      {all dead. Bool}
      (/\dead ->
         Bool_match
           (unordEqWith
              (\(v : data) ->
                 all
                   {bytestring}
                   {integer}
                   unIData
                   (\(v : integer) ->
                      ifThenElse {Bool} (equalsInteger 0 v) True False)
                   (unMapData v))
              (\(v : data) (v : data) ->
                 unordEqWith
                   (\(v : data) ->
                      ifThenElse
                        {Bool}
                        (equalsInteger 0 (unIData v))
                        True
                        False)
                   (\(v : data) (v : data) ->
                      ifThenElse
                        {Bool}
                        (equalsInteger (unIData v) (unIData v))
                        True
                        False)
                   (unMapData v)
                   (unMapData v))
              l
              r)
           {all dead. Bool}
           (/\dead -> False)
           (/\dead -> True)
           {all dead. dead})
      (/\dead -> False)
      {all dead. dead}