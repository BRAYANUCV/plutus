let
  data Unit | Unit_match where
    Unit : Unit
in
letrec
  !go : list (pair data data) -> integer
    = \(xs : list (pair data data)) ->
        caseList
          {pair data data}
          {Unit -> integer}
          (\(ds : Unit) -> 0)
          (\(x : pair data data) (xs : list (pair data data)) (ds : Unit) ->
             addInteger (unIData (sndPair {data} {data} x)) (go xs))
          xs
          Unit
in
let
  data Bool | Bool_match where
    True : Bool
    False : Bool
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
in
\(ds :
    (\k a -> list (pair data data))
      bytestring
      ((\k a -> list (pair data data)) bytestring integer))
 (cur : bytestring) ->
  Maybe_match
    {data}
    (let
      !k : data = bData cur
    in
    letrec
      !go : list (pair data data) -> Maybe data
        = \(xs : list (pair data data)) ->
            caseList
              {pair data data}
              {Unit -> Maybe data}
              (\(ds : Unit) -> Nothing {data})
              (\(x : pair data data) (xs : list (pair data data)) (ds : Unit) ->
                 Bool_match
                   (ifThenElse
                      {Bool}
                      (equalsData k (fstPair {data} {data} x))
                      True
                      False)
                   {all dead. Maybe data}
                   (/\dead -> Just {data} (sndPair {data} {data} x))
                   (/\dead -> go xs)
                   {all dead. dead})
              xs
              Unit
    in
    go ds)
    {integer}
    (\(a : data) ->
       let
         !ds : (\k a -> list (pair data data)) bytestring integer = unMapData a
       in
       go ds)
    0