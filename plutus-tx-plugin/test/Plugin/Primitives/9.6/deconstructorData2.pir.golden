program
  1.1.0
  (let
<<<<<<< HEAD
    data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
      Tuple2 : a -> b -> Tuple2 a b
    ~`$fFunctorTuple2_$cfmap` : all c a b. (a -> b) -> Tuple2 c a -> Tuple2 c b
      = /\c a b ->
          \(f : a -> b) ->
            let
              !f : a -> b = f
            in
            \(ds : Tuple2 c a) ->
              Tuple2_match
                {c}
                {a}
                ds
                {Tuple2 c b}
                (\(c : c) (a : a) -> Tuple2 {c} {b} c (f a))
    ~`$fFunctorTuple2` :
       all c. (\(f :: * -> *) -> all a b. (a -> b) -> f a -> f b) (Tuple2 c)
      = `$fFunctorTuple2_$cfmap`
  in
  letrec
    data (List :: * -> *) a | List_match where
      Nil : List a
      Cons : a -> List a -> List a
  in
  let
    ~`$fFunctorList_$cfmap` : all a b. (a -> b) -> List a -> List b
      = /\a b ->
          \(f : a -> b) ->
            let
              !f : a -> b = f
            in
            letrec
              ~go : List a -> List b
                = \(ds : List a) ->
                    List_match
                      {a}
                      ds
                      {all dead. List b}
                      (/\dead -> Nil {b})
                      (\(x : a) (xs : List a) ->
                         /\dead -> Cons {b} (f x) (go xs))
                      {all dead. dead}
            in
            \(eta : List a) -> go eta
    ~`$fFunctorList` : (\(f :: * -> *) -> all a b. (a -> b) -> f a -> f b) List
      = `$fFunctorList_$cfmap`
    ~`.` : all b c a. (b -> c) -> (a -> b) -> a -> c
      = /\b c a -> \(f : b -> c) (g : a -> b) (x : a) -> f (g x)
    ~fmap :
       all (f :: * -> *).
         (\(f :: * -> *) -> all a b. (a -> b) -> f a -> f b) f ->
         (all a b. (a -> b) -> f a -> f b)
      = /\(f :: * -> *) ->
          \(v : (\(f :: * -> *) -> all a b. (a -> b) -> f a -> f b) f) -> v
    ~`$fHasFromOpaqueBuiltinDataBuiltinData_$cfromOpaque` : data -> data
      = \(eta : data) -> eta
    !chooseList : all a b. list a -> b -> b -> b = chooseList
    !head : all a. list a -> a = headList
    !tail : all a. list a -> list a = tailList
    !unitval : unit = ()
    ~`$fHasFromOpaqueBuiltinListList_$cfromOpaque` :
       all arep a. (\arep a -> arep -> a) arep a -> list arep -> List a
      = /\arep a ->
          \(`$dHasFromOpaque` : (\arep a -> arep -> a) arep a) ->
            letrec
              ~go : list arep -> List a
                = \(l : list arep) ->
                    let
                      !l : list arep = l
                    in
                    chooseList
                      {arep}
                      {unit -> List a}
                      l
                      (\(ds : unit) -> Nil {a})
                      (\(ds : unit) ->
                         Cons
                           {a}
                           (`$dHasFromOpaque` (head {arep} l))
                           (go (tail {arep} l)))
                      unitval
            in
            \(eta : list arep) -> go eta
    !fst : all a b. pair a b -> a = fstPair
    !snd : all a b. pair a b -> b = sndPair
    !unsafeDataAsConstr : data -> pair integer (list data) = unConstrData
    ~unsafeDataAsConstr : data -> Tuple2 integer (List data)
      = \(d : data) ->
          let
            !d : data = d
            !p : pair integer (list data) = unsafeDataAsConstr d
          in
          Tuple2
            {integer}
            {List data}
            (fst {integer} {list data} p)
=======
    (nonrec)
    (datatypebind
      (datatype
        (tyvardecl Tuple2 (fun (type) (fun (type) (type))))
        (tyvardecl a (type)) (tyvardecl b (type))
        Tuple2_match
        (vardecl Tuple2 (fun a (fun b [ [ Tuple2 a ] b ])))
      )
    )
    (termbind
      (nonstrict)
      (vardecl
        `$fFunctorTuple2_$cfmap`
        (all
          c
          (type)
          (all
            a
            (type)
            (all
              b
              (type)
              (fun (fun a b) (fun [ [ Tuple2 c ] a ] [ [ Tuple2 c ] b ]))
            )
          )
        )
      )
      (abs
        c
        (type)
        (abs
          a
          (type)
          (abs
            b
            (type)
            (lam
              f
              (fun a b)
              (let
                (nonrec)
                (termbind (strict) (vardecl f (fun a b)) f)
                (lam
                  ds
                  [ [ Tuple2 c ] a ]
                  [
                    { [ { { Tuple2_match c } a } ds ] [ [ Tuple2 c ] b ] }
                    (lam c c (lam a a [ [ { { Tuple2 c } b } c ] [ f a ] ]))
                  ]
                )
              )
            )
          )
        )
      )
    )
    (termbind
      (nonstrict)
      (vardecl
        `$fFunctorTuple2`
        (all
          c
          (type)
          [
            (lam
              f
              (fun (type) (type))
              (all
                a (type) (all b (type) (fun (fun a b) (fun [ f a ] [ f b ])))
              )
            )
            [ Tuple2 c ]
          ]
        )
      )
      `$fFunctorTuple2_$cfmap`
    )
    (let
      (rec)
      (datatypebind
        (datatype
          (tyvardecl List (fun (type) (type)))
          (tyvardecl a (type))
          List_match
          (vardecl Nil [ List a ])
          (vardecl Cons (fun a (fun [ List a ] [ List a ])))
        )
      )
      (let
        (nonrec)
        (termbind
          (nonstrict)
          (vardecl
            `$fFunctorList_$cfmap`
            (all
              a
              (type)
              (all b (type) (fun (fun a b) (fun [ List a ] [ List b ])))
            )
          )
          (abs
            a
            (type)
            (abs
              b
              (type)
              (lam
                f
                (fun a b)
                (let
                  (nonrec)
                  (termbind (strict) (vardecl f (fun a b)) f)
                  (let
                    (rec)
                    (termbind
                      (nonstrict)
                      (vardecl go (fun [ List a ] [ List b ]))
                      (lam
                        ds
                        [ List a ]
                        {
                          [
                            [
                              {
                                [ { List_match a } ds ]
                                (all dead (type) [ List b ])
                              }
                              (abs dead (type) { Nil b })
                            ]
                            (lam
                              x
                              a
                              (lam
                                xs
                                [ List a ]
                                (abs
                                  dead
                                  (type)
                                  [ [ { Cons b } [ f x ] ] [ go xs ] ]
                                )
                              )
                            )
                          ]
                          (all dead (type) dead)
                        }
                      )
                    )
                    (lam eta [ List a ] [ go eta ])
                  )
                )
              )
            )
          )
        )
        (termbind
          (nonstrict)
          (vardecl
            `$fFunctorList`
            [
              (lam
                f
                (fun (type) (type))
                (all
                  a (type) (all b (type) (fun (fun a b) (fun [ f a ] [ f b ])))
                )
              )
              List
            ]
          )
          `$fFunctorList_$cfmap`
        )
        (termbind
          (nonstrict)
          (vardecl
            `.`
            (all
              b
              (type)
              (all
                c
                (type)
                (all a (type) (fun (fun b c) (fun (fun a b) (fun a c))))
              )
            )
          )
          (abs
            b
            (type)
            (abs
              c
              (type)
              (abs
                a
                (type)
                (lam f (fun b c) (lam g (fun a b) (lam x a [ f [ g x ] ])))
              )
            )
          )
        )
        (termbind
          (nonstrict)
          (vardecl
            fmap
            (all
              f
              (fun (type) (type))
              (fun
                [
                  (lam
                    f
                    (fun (type) (type))
                    (all
                      a
                      (type)
                      (all b (type) (fun (fun a b) (fun [ f a ] [ f b ])))
                    )
                  )
                  f
                ]
                (all
                  a (type) (all b (type) (fun (fun a b) (fun [ f a ] [ f b ])))
                )
              )
            )
          )
          (abs
            f
            (fun (type) (type))
            (lam
              v
              [
                (lam
                  f
                  (fun (type) (type))
                  (all
                    a
                    (type)
                    (all b (type) (fun (fun a b) (fun [ f a ] [ f b ])))
                  )
                )
                f
              ]
              v
            )
          )
        )
        (termbind
          (strict)
          (vardecl
            matchList
            (all
              a
              (type)
              (all
                r
                (type)
                (fun
                  [ (con list) a ]
                  (fun r (fun (fun a (fun [ (con list) a ] r)) r))
                )
              )
            )
          )
          (builtin caseList)
        )
        (termbind (strict) (vardecl unitval (con unit)) (con unit ()))
        (termbind
          (nonstrict)
          (vardecl
            `$fFromBuiltinBuiltinListList_$cfromBuiltin`
            (all
              arep
              (type)
              (all
                a
                (type)
                (fun
                  [ [ (lam arep (type) (lam a (type) (fun arep a))) arep ] a ]
                  (fun [ (con list) arep ] [ List a ])
                )
              )
            )
          )
          (abs
            arep
            (type)
            (abs
              a
              (type)
              (lam
                `$dFromBuiltin`
                [ [ (lam arep (type) (lam a (type) (fun arep a))) arep ] a ]
                (let
                  (rec)
                  (termbind
                    (nonstrict)
                    (vardecl go (fun [ (con list) arep ] [ List a ]))
                    (lam
                      l
                      [ (con list) arep ]
                      (let
                        (nonrec)
                        (termbind (strict) (vardecl l [ (con list) arep ]) l)
                        [
                          [
                            [
                              [
                                {
                                  { matchList arep } (fun (con unit) [ List a ])
                                }
                                l
                              ]
                              (lam ds (con unit) { Nil a })
                            ]
                            (lam
                              x
                              arep
                              (let
                                (nonrec)
                                (termbind (strict) (vardecl x arep) x)
                                (lam
                                  xs
                                  [ (con list) arep ]
                                  (let
                                    (nonrec)
                                    (termbind
                                      (strict)
                                      (vardecl xs [ (con list) arep ])
                                      xs
                                    )
                                    (lam
                                      ds
                                      (con unit)
                                      [
                                        [ { Cons a } [ `$dFromBuiltin` x ] ]
                                        [ go xs ]
                                      ]
                                    )
                                  )
                                )
                              )
                            )
                          ]
                          unitval
                        ]
                      )
                    )
                  )
                  (lam eta [ (con list) arep ] [ go eta ])
                )
              )
            )
          )
        )
        (termbind
          (strict)
          (vardecl
            fst (all a (type) (all b (type) (fun [ [ (con pair) a ] b ] a)))
          )
          (builtin fstPair)
        )
        (termbind
          (nonstrict)
          (vardecl id (all a (type) (fun a a)))
          (abs a (type) (lam x a x))
        )
        (termbind
          (strict)
          (vardecl
            snd (all a (type) (all b (type) (fun [ [ (con pair) a ] b ] b)))
          )
          (builtin sndPair)
        )
        (termbind
          (strict)
          (vardecl
            unsafeDataAsConstr
            (fun
              (con data)
              [ [ (con pair) (con integer) ] [ (con list) (con data) ] ]
            )
          )
          (builtin unConstrData)
        )
        (termbind
          (nonstrict)
          (vardecl
            unsafeDataAsConstr
            (fun (con data) [ [ Tuple2 (con integer) ] [ List (con data) ] ])
          )
          (lam
            d
            (con data)
>>>>>>> 9a46cae2f9ad5146f3566075447915502cdfcbb7
            (let
              !a : list data = snd {integer} {list data} p
            in
            `$fHasFromOpaqueBuiltinListList_$cfromOpaque`
              {data}
              {data}
              `$fHasFromOpaqueBuiltinDataBuiltinData_$cfromOpaque`
              a)
    !unsafeDataAsI : data -> integer = unIData
    ~unsafeDataAsI : data -> integer
      = \(d : data) -> let !d : data = d in unsafeDataAsI d
  in
  \(ds : data) ->
    let
      !ds : data = ds
    in
    `.`
      {List data -> List integer}
      {Tuple2 integer (List data) -> Tuple2 integer (List integer)}
      {data -> integer}
      (fmap
         {Tuple2 integer}
         (`$fFunctorTuple2` {integer})
         {List data}
         {List integer})
      (fmap {List} `$fFunctorList` {data} {integer})
      unsafeDataAsI
      (unsafeDataAsConstr ds))